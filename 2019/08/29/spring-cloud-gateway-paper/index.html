<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>spring-cloud-gateway-paper | 谢谢这个世界</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="https://wsk1103.github.io/2018/12/16/Spring-Cloud学习笔记8-spring-cloud-gateway(第二代网关)/ Spring Cloud Gateway网关研究Spring Cloud Gateway初体验Spring Cloud Gateway 之Predict篇Spring Cloud Gateway 之filter篇Spring Clo">
<meta property="og:type" content="article">
<meta property="og:title" content="spring-cloud-gateway-paper">
<meta property="og:url" content="http://yoursite.com/2019/08/29/spring-cloud-gateway-paper/index.html">
<meta property="og:site_name" content="谢谢这个世界">
<meta property="og:description" content="https://wsk1103.github.io/2018/12/16/Spring-Cloud学习笔记8-spring-cloud-gateway(第二代网关)/ Spring Cloud Gateway网关研究Spring Cloud Gateway初体验Spring Cloud Gateway 之Predict篇Spring Cloud Gateway 之filter篇Spring Clo">
<meta property="og:updated_time" content="2019-08-29T05:46:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="spring-cloud-gateway-paper">
<meta name="twitter:description" content="https://wsk1103.github.io/2018/12/16/Spring-Cloud学习笔记8-spring-cloud-gateway(第二代网关)/ Spring Cloud Gateway网关研究Spring Cloud Gateway初体验Spring Cloud Gateway 之Predict篇Spring Cloud Gateway 之filter篇Spring Clo">
  
    <link rel="alternate" href="/atom.xml" title="谢谢这个世界" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">谢谢这个世界</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-spring-cloud-gateway-paper" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/29/spring-cloud-gateway-paper/" class="article-date">
  <time datetime="2019-08-29T03:16:53.000Z" itemprop="datePublished">2019-08-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/technique/">technique</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      spring-cloud-gateway-paper
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://wsk1103.github.io/2018/12/16/Spring-Cloud学习笔记8-spring-cloud-gateway(第二代网关)/" target="_blank" rel="noopener">https://wsk1103.github.io/2018/12/16/Spring-Cloud学习笔记8-spring-cloud-gateway(第二代网关)/</a></p>
<p>Spring Cloud Gateway网关研究<br>Spring Cloud Gateway初体验<br>Spring Cloud Gateway 之Predict篇<br>Spring Cloud Gateway 之filter篇<br>Spring Cloud Gateway 之限流篇<br>spring cloud gateway之服务注册与发现</p>
<p>简介<br>网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。Spring Cloud Gateway是Spring Cloud体系的第二代网关组件，基于Spring 5.0的新特性WebFlux进行开发，底层网络通信框架使用的是Netty，所以其吞吐量高、性能强劲，未来将会取代第一代的网关组件Zuul。本文将以成体系的的方式逐步介绍Spring Cloud Gateway。</p>
<p>创建工程<br>本案例的的源码下载于官方案例，工程使用的Spring Boot版本为2.0.5.RELEASE，Spring Cloud版本为Finchley.SR1。<br>新建一个工程，取名为sc-f-gateway-first-sight在工程的pom文件引用工程所需的依赖，包括spring boot和spring cloud，以及gateway的起步依赖spring-cloud-starter-gateway，代码如下：<br>   <parent><br>        <groupid>org.springframework.boot</groupid><br>        <artifactid>spring-boot-starter-parent</artifactid><br>        <version>2.0.5.RELEASE</version><br>    </parent></p>
<pre><code>&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;Finchley.SR1&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre> <dependency><br>            <groupid>org.springframework.cloud</groupid><br>            <artifactid>spring-cloud-starter-gateway</artifactid><br></dependency><br><strong> 注：详细的pom文件依赖，可以见源码。</strong><br><br>创建一个简单的路由<br>在spring cloud gateway中使用RouteLocator的Bean进行路由转发，将请求进行处理，最后转发到目标的下游服务。在本案例中，会将请求转发到<a href="http://httpbin.org:80这个地址上。代码如下：" target="_blank" rel="noopener">http://httpbin.org:80这个地址上。代码如下：</a><br>@SpringBootApplication<br>@RestController<br>public class Application {<br><br>    public static void main(String[] args) {<br>        SpringApplication.run(Application.class, args);<br>    }<br>    @Bean<br>    public RouteLocator myRoutes(RouteLocatorBuilder builder) {<br>       return builder.routes()<br>        .route(p -&gt; p<br>            .path(“/get”)<br>            .filters(f -&gt; f.addRequestHeader(“Hello”, “World”))<br>            .uri(“<a href="http://httpbin.org:80" target="_blank" rel="noopener">http://httpbin.org:80</a>“))<br>        .build();<br>}<br>}<br>在上面的myRoutes方法中，使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。<br><br>上面创建的route可以让请求“/get”请求都转发到“<a href="http://httpbin.org/get”。在route配置上，我们添加了一个filter，该filter会将请求添加一个header,key为hello，value为world。" target="_blank" rel="noopener">http://httpbin.org/get”。在route配置上，我们添加了一个filter，该filter会将请求添加一个header,key为hello，value为world。</a><br><br>启动springboot项目，在浏览器上<a href="http://localhost:8080/get，浏览器显示如下" target="_blank" rel="noopener">http://localhost:8080/get，浏览器显示如下</a>:<br><br>{<br>  “args”: {},<br>  “headers”: {<br>    “Accept”: “text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8”,<br>    “Accept-Encoding”: “gzip, deflate, br”,<br>    “Accept-Language”: “zh-CN,zh;q=0.9,en;q=0.8”,<br>    “Cache-Control”: “max-age=0”,<br>    “Connection”: “close”,<br>    “Cookie”: “_ga=GA1.1.412536205.1526967566; JSESSIONID.667921df=node01oc1cdl4mcjdx1mku2ef1l440q1.node0; screenResolution=1920x1200”,<br>    “Forwarded”: “proto=http;host=\”localhost:8080\”;for=\”0:0:0:0:0:0:0:1:60036\””,<br>    “Hello”: “World”,<br>    “Host”: “httpbin.org”,<br>    “Upgrade-Insecure-Requests”: “1”,<br>    “User-Agent”: “Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36”,<br>    “X-Forwarded-Host”: “localhost:8080”<br>  },<br>  “origin”: “0:0:0:0:0:0:0:1, 210.22.21.66”,<br>  “url”: “<a href="http://localhost:8080/get" target="_blank" rel="noopener">http://localhost:8080/get</a>“<br>}<br><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>可见当我们向gateway工程请求“/get”,gateway会将工程的请求转发到“<a href="http://httpbin.org/get”，并且在转发之前，加上一个filter，该filter会将请求添加一个header,key为hello，value为world。" target="_blank" rel="noopener">http://httpbin.org/get”，并且在转发之前，加上一个filter，该filter会将请求添加一个header,key为hello，value为world。</a><br><br>注意HTTPBin展示了请求的header hello和值world。<br><br>使用Hystrix<br><br>在spring cloud gateway中可以使用Hystrix。Hystrix是 spring cloud中一个服务熔断降级的组件，在微服务系统有着十分重要的作用。<br>Hystrix是 spring cloud gateway中是以filter的形式使用的，代码如下：<br><br>   @Bean<br>    public RouteLocator myRoutes(RouteLocatorBuilder builder) {<br>        String httpUri = “<a href="http://httpbin.org:80" target="_blank" rel="noopener">http://httpbin.org:80</a>“;<br>        return builder.routes()<br>            .route(p -&gt; p<br>                .path(“/get”)<br>                .filters(f -&gt; f.addRequestHeader(“Hello”, “World”))<br>                .uri(httpUri))<br>            .route(p -&gt; p<br>                .host(“<em>.hystrix.com”)<br>                .filters(f -&gt; f<br>                    .hystrix(config -&gt; config<br>                        .setName(“mycmd”)<br>                        .setFallbackUri(“forward:/fallback”)))<br>                .uri(httpUri))<br>            .build();<br>    }<br><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>在上面的代码中，我们使用了另外一个router，该router使用host去断言请求是否进入该路由，当请求的host有“</em>.hystrix.com”，都会进入该router，该router中有一个hystrix的filter,该filter可以配置名称、和指向性fallback的逻辑的地址，比如本案例中重定向到了“/fallback”。<br><br>现在写的一个“/fallback”的l逻辑：<br><br><br> @RequestMapping(“/fallback”)<br>    public Mono<string> fallback() {<br>        return Mono.just(“fallback”);<br>    }<br><br>1<br>2<br>3<br>4<br>5<br>6<br>Mono是一个Reactive stream，对外输出一个“fallback”字符串。<br><br>使用curl执行以下命令：<br><br> curl –dump-header - –header ‘Host: www.hystrix.com’ <a href="http://localhost:8080/delay/3" target="_blank" rel="noopener">http://localhost:8080/delay/3</a><br><br>1<br>2<br>返回的响应为：<br><br>fallback<br>1<br>可见，带hostwww.hystrix.com的请求执行了hystrix的fallback的逻辑。<br><br>总结<br><br>本文通过官方的一个简单的案例，来讲解了spring cloud gateway的简单用法，在spring cloud gateway中有2个重要的概念predicates和filters，它们个将会在后续文章讲解。敬请期待。<br><br><br><br><br><br><br>Spring Cloud gateway工作流程<br><br>在之前的文章的Spring Cloud Gateway初体验中，大家已经对Spring Cloud Gateway的功能有一个初步的认识，网关作为一个系统的流量的入口，有着举足轻重的作用，通常的作用如下：<br><br>协议转换，路由转发<br>流量聚合，对流量进行监控，日志输出<br>作为整个系统的前端工程，对流量进行控制，有限流的作用<br>作为系统的前端边界，外部流量只能通过网关才能访问系统<br>可以在网关层做权限的判断<br>可以在网关层做缓存<br>Spring Cloud Gateway作为Spring Cloud框架的第二代网关，在功能上要比Zuul更加的强大，性能也更好。随着Spring Cloud的版本迭代，Spring Cloud官方有打算弃用Zuul的意思。在笔者调用了Spring Cloud Gateway的使用和功能上，Spring Cloud Gateway替换掉Zuul的成本上是非常低的，几乎可以无缝切换。Spring Cloud Gateway几乎包含了zuul的所有功能。<br><br><br><br>注：该图片来自官网<br><br>如上图所示，客户端向Spring Cloud Gateway发出请求。 如果Gateway Handler Mapping确定请求与路由匹配（这个时候就用到predicate），则将其发送到Gateway web handler处理。 Gateway web handler处理请求时会经过一系列的过滤器链。 过滤器链被虚线划分的原因是过滤器链可以在发送代理请求之前或之后执行过滤逻辑。 先执行所有“pre”过滤器逻辑，然后进行代理请求。 在发出代理请求之后，收到代理服务的响应之后执行“post”过滤器逻辑。这跟zuul的处理过程很类似。在执行所有“pre”过滤器逻辑时，往往进行了鉴权、限流、日志输出等功能，以及请求头的更改、协议的转换；转发之后收到响应之后，会执行所有“post”过滤器的逻辑，在这里可以响应数据进行了修改，比如响应头、协议的转换等。<br><br>在上面的处理过程中，有一个重要的点就是讲请求和路由进行匹配，这时候就需要用到predicate，它是决定了一个请求走哪一个路由。<br><br>predicate简介<br><br>Predicate来自于java8的接口。Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。add–与、or–或、negate–非。<br>Spring Cloud Gateway内置了许多Predict,这些Predict的源码在org.springframework.cloud.gateway.handler.predicate包中，如果读者有兴趣可以阅读一下。现在列举各种Predicate如下图：<br><br><br><br>注：图片来自网络<br><br>在上图中，有很多类型的Predicate,比如说时间类型的Predicated（AfterRoutePredicateFactory BeforeRoutePredicateFactory BetweenRoutePredicateFactory），当只有满足特定时间要求的请求会进入到此predicate中，并交由router处理；cookie类型的CookieRoutePredicateFactory，指定的cookie满足正则匹配，才会进入此router;以及host、method、path、querparam、remoteaddr类型的predicate，每一种predicate都会对当前的客户端请求进行判断，是否满足当前的要求，如果满足则交给当前请求处理。如果有很多个Predicate，并且一个请求满足多个Predicate，则按照配置的顺序第一个生效。<br><br>predicate实战<br><br>现在以案例的形式来讲解predicate，本文中的案例基本来源于官方文档，官方文档地址：<a href="http://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.0.0.RELEASE/single/spring-cloud-gateway.html" target="_blank" rel="noopener">http://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.0.0.RELEASE/single/spring-cloud-gateway.html</a> ；如果有任何问题欢迎和我联系，和我讨论。<br><br>创建一个工程，在工程的pom文件引入spring cloud gateway 的起步依赖spring-cloud-starter-gateway，spring cloud版本和spring boot版本，代码如下：<br><br><br>  <parent><br>       <groupid>org.springframework.boot</groupid><br>       <artifactid>spring-boot-starter-parent</artifactid><br>       <version>2.0.5.RELEASE</version><br>   </parent><br><br>   <dependencymanagement><br>       <dependencies><br>           <dependency><br>               <groupid>org.springframework.cloud</groupid><br>               <artifactid>spring-cloud-dependencies</artifactid><br>               <version>Finchley.SR1</version><br>               <type>pom</type><br>               <scope>import</scope><br>           </dependency><br>       </dependencies><br>   </dependencymanagement><br><br> <dependency><br>     <groupid>org.springframework.cloud</groupid><br>     <artifactid>spring-cloud-starter-gateway</artifactid><br> </dependency>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>After Route Predicate Factory</p>
<p>AfterRoutePredicateFactory，可配置一个时间，当请求的时间在配置时间之后，才交给 router去处理。否则则报错，不通过路由。</p>
<p>在工程的application.yml配置如下：</p>
<p>server:<br>  port: 8081<br>spring:<br>  profiles:<br>    active: after_route</p>
<hr>
<p>spring:<br>  cloud:<br>    gateway:<br>      routes:</p>
<pre><code>- id: after_route
  uri: http://httpbin.org:80/get
  predicates:
  - After=2017-01-20T17:42:47.789-07:00[America/Denver]
</code></pre><p>  profiles: after_route</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>在上面的配置文件中，配置了服务的端口为8081，配置spring.profiles.active:after_route指定了程序的spring的启动文件为after_route文件。在application.yml再建一个配置文件，语法是三个横线，在此配置文件中通过spring.profiles来配置文件名，和spring.profiles.active一致，然后配置spring cloud gateway 相关的配置，id标签配置的是router的id，每个router都需要一个唯一的id，uri配置的是将请求路由到哪里，本案例全部路由到<a href="http://httpbin.org:80/get。" target="_blank" rel="noopener">http://httpbin.org:80/get。</a></p>
<p>predicates：<br>After=2017-01-20T17:42:47.789-07:00[America/Denver] 会被解析成PredicateDefinition对象 （name =After ，args= 2017-01-20T17:42:47.789-07:00[America/Denver]）。在这里需要注意的是predicates的After这个配置，遵循的契约大于配置的思想，它实际被AfterRoutePredicateFactory这个类所处理，这个After就是指定了它的Gateway web handler类为AfterRoutePredicateFactory，同理，其他类型的predicate也遵循这个规则。</p>
<p>当请求的时间在这个配置的时间之后，请求会被路由到<a href="http://httpbin.org:80/get。" target="_blank" rel="noopener">http://httpbin.org:80/get。</a></p>
<p>启动工程，在浏览器上访问<a href="http://localhost:8081/，会显示http://httpbin.org:80/get返回的结果，此时gateway路由到了配置的uri。如果我们将配置的时间设置到当前时之后，浏览器会显示404，此时证明没有路由到配置的uri" target="_blank" rel="noopener">http://localhost:8081/，会显示http://httpbin.org:80/get返回的结果，此时gateway路由到了配置的uri。如果我们将配置的时间设置到当前时之后，浏览器会显示404，此时证明没有路由到配置的uri</a>.</p>
<p>跟时间相关的predicates还有Before Route Predicate Factory、Between Route Predicate Factory，读者可以自行查阅官方文档，再次不再演示。</p>
<p>Header Route Predicate Factory</p>
<p>Header Route Predicate Factory需要2个参数，一个是header名，另外一个header值，该值可以是一个正则表达式。当此断言匹配了请求的header名和值时，断言通过，进入到router的规则中去。</p>
<p>在工程的配置文件加上以下的配置：</p>
<p>spring:<br>  profiles:<br>    active: header_route</p>
<hr>
<p>spring:<br>  cloud:<br>    gateway:<br>      routes:</p>
<pre><code>- id: header_route
  uri: http://httpbin.org:80/get
  predicates:
  - Header=X-Request-Id, \d+
</code></pre><p>  profiles: header_route</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>在上面的配置中，当请求的Header中有X-Request-Id的header名，且header值为数字时，请求会被路由到配置的 uri. 使用curl执行以下命令:</p>
<p>$ curl -H ‘X-Request-Id:1’ localhost:8081</p>
<p>1<br>2<br>执行命令后，会正确的返回请求结果，结果省略。如果在请求中没有带上X-Request-Id的header名，并且值不为数字时，请求就会报404，路由没有被正确转发。</p>
<p>Cookie Route Predicate Factory</p>
<p>Cookie Route Predicate Factory需要2个参数，一个时cookie名字，另一个时值，可以为正则表达式。它用于匹配请求中，带有该名称的cookie和cookie匹配正则表达式的请求。</p>
<p>在配置文件添加以下配置：</p>
<p>spring:<br>  profiles:<br>    active: cookie_route</p>
<hr>
<p>spring:<br>  cloud:<br>    gateway:<br>      routes:</p>
<pre><code>- id: cookie_route
  uri: http://httpbin.org:80/get
  predicates:
  - Cookie=name, forezp
</code></pre><p>  profiles: cookie_route</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>在上面的配置中，请求带有cookie名为<br>name, cookie值为forezp 的请求将都会转发到uri为 <a href="http://httpbin.org:80/get的地址上。" target="_blank" rel="noopener">http://httpbin.org:80/get的地址上。</a><br>使用curl命令进行请求，在请求中带上 cookie，会返回正确的结果，否则，请求报404错误。</p>
<p>$ curl -H ‘Cookie:name=forezp’ localhost:8081</p>
<p>1<br>2<br>Host Route Predicate Factory</p>
<p>Host Route Predicate Factory需要一个参数即hostname，它可以使用. * 等去匹配host。这个参数会匹配请求头中的host的值，一致，则请求正确转发。</p>
<p>在工程的配置文件，加上以下配置：</p>
<p>spring:<br>  profiles:</p>
<pre><code>active: host_route
</code></pre><hr>
<p>spring:<br>  cloud:<br>    gateway:<br>      routes:</p>
<pre><code>- id: host_route
  uri: http://httpbin.org:80/get
  predicates:
  - Host=**.fangzhipeng.com
</code></pre><p>  profiles: host_route<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>在上面的配置中，请求头中含有Host为fangzhipeng.com的请求将会被路由转发转发到配置的uri。 启动工程，执行以下的curl命令，请求会返回正确的请求结果：</p>
<p>curl -H ‘Host:www.fangzhipeng.com’ localhost:8081</p>
<p>1<br>2<br>3<br>Method Route Predicate Factory</p>
<p>Method Route Predicate Factory 需要一个参数，即请求的类型。比如GET类型的请求都转发到此路由。在工程的配置文件加上以下的配置：</p>
<p>spring:<br>  profiles:<br>    active: method_route</p>
<hr>
<p>spring:<br>  cloud:<br>    gateway:<br>      routes:</p>
<pre><code>- id: method_route
  uri: http://httpbin.org:80/get
  predicates:
  - Method=GET
</code></pre><p>  profiles: method_route</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>在上面的配置中，所有的GET类型的请求都会路由转发到配置的uri。使用 curl命令模拟 get类型的请求，会得到正确的返回结果。</p>
<p>$ curl localhost:8081</p>
<p>1<br>2<br>3<br>使用 curl命令模拟 post请求，则返回404结果。</p>
<p>$ curl -XPOST localhost:8081</p>
<p>1<br>2<br>Path Route Predicate Factory</p>
<p>Path Route Predicate Factory 需要一个参数: 一个spel表达式，应用匹配路径。</p>
<p>在工程的配置文件application.yml文件中，做以下的配置：</p>
<p>spring:<br>  profiles:</p>
<pre><code>active: path_route
</code></pre><hr>
<p>spring:<br>  cloud:<br>    gateway:<br>      routes:</p>
<pre><code>- id: path_route
  uri: http://httpbin.org:80/get
  predicates:
  - Path=/foo/{segment}
</code></pre><p>  profiles: path_route</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>在上面的配置中，所有的请求路径满足/foo/{segment}的请求将会匹配并被路由，比如/foo/1 、/foo/bar的请求，将会命中匹配，并成功转发。</p>
<p>使用curl模拟一个请求localhost:8081/foo/dew，执行之后会返回正确的请求结果。</p>
<p>$ curl localhost:8081/foo/dew</p>
<p>1<br>2<br>Query Route Predicate Factory</p>
<p>Query Route Predicate Factory 需要2个参数:一个参数名和一个参数值的正则表达式。在工程的配置文件application.yml做以下的配置：</p>
<p>spring:<br>  profiles:</p>
<pre><code>active: query_route
</code></pre><hr>
<p>spring:<br>  cloud:<br>    gateway:<br>      routes:</p>
<pre><code>- id: query_route
  uri: http://httpbin.org:80/get
  predicates:
  - Query=foo, ba.
</code></pre><p>  profiles: query_route</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>在上面的配置文件中，配置了请求中含有参数foo，并且foo的值匹配ba.，则请求命中路由，比如一个请求中含有参数名为foo，值的为bar，能够被正确路由转发。</p>
<p>模拟请求的命令如下：</p>
<p>$ curl localhost:8081?foo=bar</p>
<p>1<br>2<br>3<br>Query Route Predicate Factory也可以只填一个参数，填一个参数时，则只匹配参数名，即请求的参数中含有配置的参数名，则命中路由。比如以下的配置中，配置了请求参数中含有参数名为foo 的参数将会被请求转发到uri为<a href="http://httpbin.org:80/get。" target="_blank" rel="noopener">http://httpbin.org:80/get。</a></p>
<p>spring:<br>  cloud:<br>    gateway:<br>      routes:</p>
<pre><code>- id: query_route
  uri: http://httpbin.org:80/get
  predicates:
  - Query=foo
</code></pre><p>  profiles: query_route</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>总结</p>
<p>在本篇文章中，首先介绍了Spring Cloud Gateway的工作流程和原理，然后介绍了gateway框架内置的predict及其分类，最后以案例的形式重点讲解了几个重要的Predict。Predict作为断言，它决定了请求会被路由到哪个router 中。在断言之后，请求会被进入到filter过滤器的逻辑，下篇文章将会为大家介绍Spring Cloud Gateway过滤器相关的内容。</p>
<p>在上一篇文章详细的介绍了Gateway的Predict，Predict决定了请求由哪一个路由处理，在路由处理之前，需要经过“pre”类型的过滤器处理，处理返回响应之后，可以由“post”类型的过滤器处理。</p>
<p>filter的作用和生命周期</p>
<p>由filter工作流程点，可以知道filter有着非常重要的作用，在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等。首先需要弄清一点为什么需要网关这一层，这就不得不说下filter的作用了。</p>
<p>作用</p>
<p>当我们有很多个服务时，比如下图中的user-service、goods-service、sales-service等服务，客户端请求各个服务的Api时，每个服务都需要做相同的事情，比如鉴权、限流、日志输出等。</p>
<p>对于这样重复的工作，有没有办法做的更好，答案是肯定的。在微服务的上一层加一个全局的权限控制、限流、日志输出的Api Gatewat服务，然后再将请求转发到具体的业务服务层。这个Api Gateway服务就是起到一个服务边界的作用，外接的请求访问系统，必须先通过网关层。</p>
<p>生命周期</p>
<p>Spring Cloud Gateway同zuul类似，有“pre”和“post”两种方式的filter。客户端的请求先经过“pre”类型的filter，然后将请求转发到具体的业务服务，比如上图中的user-service，收到业务服务的响应之后，再经过“post”类型的filter处理，最后返回响应到客户端。</p>
<p>与zuul不同的是，filter除了分为“pre”和“post”两种方式的filter外，在Spring Cloud Gateway中，filter从作用范围可分为另外两种，一种是针对于单个路由的gateway filter，它在配置文件中的写法同predict类似；另外一种是针对于所有路由的global gateway filer。现在从作用范围划分的维度来讲解这两种filter。</p>
<p>gateway filter</p>
<p>过滤器允许以某种方式修改传入的HTTP请求或传出的HTTP响应。过滤器可以限定作用在某些特定请求路径上。 Spring Cloud Gateway包含许多内置的GatewayFilter工厂。</p>
<p>GatewayFilter工厂同上一篇介绍的Predicate工厂类似，都是在配置文件application.yml中配置，遵循了约定大于配置的思想，只需要在配置文件配置GatewayFilter Factory的名称，而不需要写全部的类名，比如AddRequestHeaderGatewayFilterFactory只需要在配置文件中写AddRequestHeader，而不是全部类名。在配置文件中配置的GatewayFilter Factory最终都会相应的过滤器工厂类处理。</p>
<p>Spring Cloud Gateway 内置的过滤器工厂一览表如下：</p>
<p>现在挑几个常见的过滤器工厂来讲解，每一个过滤器工厂在官方文档都给出了详细的使用案例，如果不清楚的还可以在org.springframework.cloud.gateway.filter.factory看每一个过滤器工厂的源码。</p>
<p>AddRequestHeader GatewayFilter Factory</p>
<p>创建工程，引入相关的依赖,包括spring boot 版本2.0.5，spring Cloud版本Finchley，gateway依赖如下：</p>
<dependency><br>    <groupid>org.springframework.cloud</groupid><br>    <artifactid>spring-cloud-starter-gateway</artifactid><br></dependency>

<p>1<br>2<br>3<br>4<br>5<br>在工程的配置文件中，加入以下的配置：</p>
<p>server:<br>  port: 8081<br>spring:<br>  profiles:<br>    active: add_request_header_route</p>
<hr>
<p>spring:<br>  cloud:<br>    gateway:<br>      routes:</p>
<pre><code>- id: add_request_header_route
  uri: http://httpbin.org:80/get
  filters:
  - AddRequestHeader=X-Request-Foo, Bar
  predicates:
  - After=2017-01-20T17:42:47.789-07:00[America/Denver]
</code></pre><p>  profiles: add_request_header_route</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>在上述的配置中，工程的启动端口为8081，配置文件为add_request_header_route，在add_request_header_route配置中，配置了roter的id为add_request_header_route，路由地址为<a href="http://httpbin.org:80/get，该router有AfterPredictFactory，有一个filter为AddRequestHeaderGatewayFilterFactory(约定写成AddRequestHeader)，AddRequestHeader过滤器工厂会在请求头加上一对请求头，名称为X-Request-Foo，值为Bar。为了验证AddRequestHeaderGatewayFilterFactory是怎么样工作的，查看它的源码，AddRequestHeaderGatewayFilterFactory的源码如下：" target="_blank" rel="noopener">http://httpbin.org:80/get，该router有AfterPredictFactory，有一个filter为AddRequestHeaderGatewayFilterFactory(约定写成AddRequestHeader)，AddRequestHeader过滤器工厂会在请求头加上一对请求头，名称为X-Request-Foo，值为Bar。为了验证AddRequestHeaderGatewayFilterFactory是怎么样工作的，查看它的源码，AddRequestHeaderGatewayFilterFactory的源码如下：</a></p>
<p>public class AddRequestHeaderGatewayFilterFactory extends AbstractNameValueGatewayFilterFactory {</p>
<pre><code>@Override
public GatewayFilter apply(NameValueConfig config) {
    return (exchange, chain) -&gt; {
        ServerHttpRequest request = exchange.getRequest().mutate()
                .header(config.getName(), config.getValue())
                .build();

        return chain.filter(exchange.mutate().request(request).build());
    };
}
</code></pre><p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>由上面的代码可知，根据旧的ServerHttpRequest创建新的 ServerHttpRequest ，在新的ServerHttpRequest加了一个请求头，然后创建新的 ServerWebExchange ，提交过滤器链继续过滤。</p>
<p>启动工程，通过curl命令来模拟请求：</p>
<p>curl localhost:8081</p>
<p>1<br>2<br>3<br>最终显示了从 <a href="http://httpbin.org:80/get得到了请求，响应如下：" target="_blank" rel="noopener">http://httpbin.org:80/get得到了请求，响应如下：</a></p>
<p>{<br>  “args”: {},<br>  “headers”: {<br>    “Accept”: “<em>/</em>“,<br>    “Connection”: “close”,<br>    “Forwarded”: “proto=http;host=\”localhost:8081\”;for=\”0:0:0:0:0:0:0:1:56248\””,<br>    “Host”: “httpbin.org”,<br>    “User-Agent”: “curl/7.58.0”,<br>    “X-Forwarded-Host”: “localhost:8081”,<br>    “X-Request-Foo”: “Bar”<br>  },<br>  “origin”: “0:0:0:0:0:0:0:1, 210.22.21.66”,<br>  “url”: “<a href="http://localhost:8081/get" target="_blank" rel="noopener">http://localhost:8081/get</a>“<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>可以上面的响应可知，确实在请求头中加入了X-Request-Foo这样的一个请求头，在配置文件中配置的AddRequestHeader过滤器工厂生效。</p>
<p>跟AddRequestHeader过滤器工厂类似的还有AddResponseHeader过滤器工厂，在此就不再重复。</p>
<p>RewritePath GatewayFilter Factory</p>
<p>在Nginx服务启中有一个非常强大的功能就是重写路径，Spring Cloud Gateway默认也提供了这样的功能，这个功能是Zuul没有的。在配置文件中加上以下的配置：</p>
<p>spring:<br>  profiles:</p>
<pre><code>active: rewritepath_route
</code></pre><hr>
<p>spring:<br>  cloud:<br>    gateway:<br>      routes:</p>
<pre><code>- id: rewritepath_route
  uri: https://blog.csdn.net
  predicates:
  - Path=/foo/**
  filters:
  - RewritePath=/foo/(?&lt;segment&gt;.*), /$\{segment}
</code></pre><p>  profiles: rewritepath_route</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>上面的配置中，所有的/foo/<em>*开始的路径都会命中配置的router，并执行过滤器的逻辑，在本案例中配置了RewritePath过滤器工厂，此工厂将/foo/(?.</em>)重写为{segment}，然后转发到<a href="https://blog.csdn.net。比如在网页上请求localhost:8081/foo/forezp，此时会将请求转发到https://blog.csdn.net/forezp的页面，比如在网页上请求localhost:8081/foo/forezp/1，页面显示404，就是因为不存在https://blog.csdn.net/forezp/1这个页面。" target="_blank" rel="noopener">https://blog.csdn.net。比如在网页上请求localhost:8081/foo/forezp，此时会将请求转发到https://blog.csdn.net/forezp的页面，比如在网页上请求localhost:8081/foo/forezp/1，页面显示404，就是因为不存在https://blog.csdn.net/forezp/1这个页面。</a></p>
<p>自定义过滤器</p>
<p>Spring Cloud Gateway内置了19种强大的过滤器工厂，能够满足很多场景的需求，那么能不能自定义自己的过滤器呢，当然是可以的。在spring Cloud Gateway中，过滤器需要实现GatewayFilter和Ordered2个接口。写一个RequestTimeFilter，代码如下：</p>
<p>public class RequestTimeFilter implements GatewayFilter, Ordered {</p>
<pre><code>private static final Log log = LogFactory.getLog(GatewayFilter.class);
private static final String REQUEST_TIME_BEGIN = &quot;requestTimeBegin&quot;;

@Override
public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {

    exchange.getAttributes().put(REQUEST_TIME_BEGIN, System.currentTimeMillis());
    return chain.filter(exchange).then(
            Mono.fromRunnable(() -&gt; {
                Long startTime = exchange.getAttribute(REQUEST_TIME_BEGIN);
                if (startTime != null) {
                    log.info(exchange.getRequest().getURI().getRawPath() + &quot;: &quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);
                }
            })
    );

}

@Override
public int getOrder() {
    return 0;
}
</code></pre><p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>在上面的代码中，Ordered中的int getOrder()方法是来给过滤器设定优先级别的，值越大则优先级越低。还有有一个filterI(exchange,chain)方法，在该方法中，先记录了请求的开始时间，并保存在ServerWebExchange中，此处是一个“pre”类型的过滤器，然后再chain.filter的内部类中的run()方法中相当于”post”过滤器，在此处打印了请求所消耗的时间。然后将该过滤器注册到router中，代码如下：</p>
<pre><code>@Bean
public RouteLocator customerRouteLocator(RouteLocatorBuilder builder) {
    // @formatter:off
    return builder.routes()
            .route(r -&gt; r.path(&quot;/customer/**&quot;)
                    .filters(f -&gt; f.filter(new RequestTimeFilter())
                            .addResponseHeader(&quot;X-Response-Default-Foo&quot;, &quot;Default-Bar&quot;))
                    .uri(&quot;http://httpbin.org:80/get&quot;)
                    .order(0)
                    .id(&quot;customer_filter_router&quot;)
            )
            .build();
    // @formatter:on
}
</code></pre><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>重启程序，通过curl命令模拟请求：</p>
<p> curl localhost:8081/customer/123</p>
<p>1<br>2<br>在程序的控制台输出一下的请求信息的日志：</p>
<p>2018-11-16 15:02:20.177  INFO 20488 — [ctor-http-nio-3] o.s.cloud.gateway.filter.GatewayFilter   : /customer/123: 152ms</p>
<p>1<br>2<br>3<br>自定义过滤器工厂</p>
<p>在上面的自定义过滤器中，有没有办法自定义过滤器工厂类呢?这样就可以在配置文件中配置过滤器了。现在需要实现一个过滤器工厂，在打印时间的时候，可以设置参数来决定是否打印请参数。查看GatewayFilterFactory的源码，可以发现GatewayFilterfactory的层级如下：</p>
<p>过滤器工厂的顶级接口是GatewayFilterFactory，我们可以直接继承它的两个抽象类来简化开发AbstractGatewayFilterFactory和AbstractNameValueGatewayFilterFactory，这两个抽象类的区别就是前者接收一个参数（像StripPrefix和我们创建的这种），后者接收两个参数（像AddResponseHeader）。</p>
<p>过滤器工厂的顶级接口是GatewayFilterFactory，有2个两个较接近具体实现的抽象类，分别为AbstractGatewayFilterFactory和AbstractNameValueGatewayFilterFactory，这2个类前者接收一个参数，比如它的实现类RedirectToGatewayFilterFactory；后者接收2个参数，比如它的实现类AddRequestHeaderGatewayFilterFactory类。现在需要将请求的日志打印出来，需要使用一个参数，这时可以参照RedirectToGatewayFilterFactory的写法。</p>
<p>public class RequestTimeGatewayFilterFactory extends AbstractGatewayFilterFactory<requesttimegatewayfilterfactory.config> {</requesttimegatewayfilterfactory.config></p>
<pre><code>private static final Log log = LogFactory.getLog(GatewayFilter.class);
private static final String REQUEST_TIME_BEGIN = &quot;requestTimeBegin&quot;;
private static final String KEY = &quot;withParams&quot;;

@Override
public List&lt;String&gt; shortcutFieldOrder() {
    return Arrays.asList(KEY);
}

public RequestTimeGatewayFilterFactory() {
    super(Config.class);
}

@Override
public GatewayFilter apply(Config config) {
    return (exchange, chain) -&gt; {
        exchange.getAttributes().put(REQUEST_TIME_BEGIN, System.currentTimeMillis());
        return chain.filter(exchange).then(
                Mono.fromRunnable(() -&gt; {
                    Long startTime = exchange.getAttribute(REQUEST_TIME_BEGIN);
                    if (startTime != null) {
                        StringBuilder sb = new StringBuilder(exchange.getRequest().getURI().getRawPath())
                                .append(&quot;: &quot;)
                                .append(System.currentTimeMillis() - startTime)
                                .append(&quot;ms&quot;);
                        if (config.isWithParams()) {
                            sb.append(&quot; params:&quot;).append(exchange.getRequest().getQueryParams());
                        }
                        log.info(sb.toString());
                    }
                })
        );
    };
}


public static class Config {

    private boolean withParams;

    public boolean isWithParams() {
        return withParams;
    }

    public void setWithParams(boolean withParams) {
        this.withParams = withParams;
    }

}
</code></pre><p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>在上面的代码中 apply(Config config)方法内创建了一个GatewayFilter的匿名类，具体的实现逻辑跟之前一样，只不过加了是否打印请求参数的逻辑，而这个逻辑的开关是config.isWithParams()。静态内部类类Config就是为了接收那个boolean类型的参数服务的，里边的变量名可以随意写，但是要重写List shortcutFieldOrder()这个方法。<br>。</p>
<p>需要注意的是，在类的构造器中一定要调用下父类的构造器把Config类型传过去，否则会报ClassCastException</p>
<p>最后，需要在工程的启动文件Application类中，向Srping Ioc容器注册RequestTimeGatewayFilterFactory类的Bean。</p>
<pre><code>@Bean
public RequestTimeGatewayFilterFactory elapsedGatewayFilterFactory() {
    return new RequestTimeGatewayFilterFactory();
}
</code></pre><p>1<br>2<br>3<br>4<br>5<br>6<br>然后可以在配置文件中配置如下：</p>
<p>spring:<br>  profiles:<br>    active: elapse_route</p>
<hr>
<p>spring:<br>  cloud:<br>    gateway:<br>      routes:</p>
<pre><code>- id: elapse_route
  uri: http://httpbin.org:80/get
  filters:
  - RequestTime=false
  predicates:
  - After=2017-01-20T17:42:47.789-07:00[America/Denver]
</code></pre><p>  profiles: elapse_route</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>启动工程，在浏览器上访问localhost:8081?name=forezp，可以在控制台上看到，日志输出了请求消耗的时间和请求参数。</p>
<p>global filter</p>
<p>Spring Cloud Gateway根据作用范围划分为GatewayFilter和GlobalFilter，二者区别如下：</p>
<p>GatewayFilter : 需要通过spring.cloud.routes.filters 配置在具体路由下，只作用在当前路由上或通过spring.cloud.default-filters配置在全局，作用在所有路由上</p>
<p>GlobalFilter : 全局过滤器，不需要在配置文件中配置，作用在所有的路由上，最终通过GatewayFilterAdapter包装成GatewayFilterChain可识别的过滤器，它为请求业务以及路由的URI转换为真实业务服务的请求地址的核心过滤器，不需要配置，系统初始化时加载，并作用在每个路由上。</p>
<p>Spring Cloud Gateway框架内置的GlobalFilter如下：</p>
<p>上图中每一个GlobalFilter都作用在每一个router上，能够满足大多数的需求。但是如果遇到业务上的定制，可能需要编写满足自己需求的GlobalFilter。在下面的案例中将讲述如何编写自己GlobalFilter，该GlobalFilter会校验请求中是否包含了请求参数“token”，如何不包含请求参数“token”则不转发路由，否则执行正常的逻辑。代码如下：</p>
<p>public class TokenFilter implements GlobalFilter, Ordered {</p>
<pre><code>Logger logger=LoggerFactory.getLogger( TokenFilter.class );
@Override
public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
    String token = exchange.getRequest().getQueryParams().getFirst(&quot;token&quot;);
    if (token == null || token.isEmpty()) {
        logger.info( &quot;token is empty...&quot; );
        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
        return exchange.getResponse().setComplete();
    }
    return chain.filter(exchange);
}

@Override
public int getOrder() {
    return -100;
}
</code></pre><p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>在上面的TokenFilter需要实现GlobalFilter和Ordered接口，这和实现GatewayFilter很类似。然后根据ServerWebExchange获取ServerHttpRequest，然后根据ServerHttpRequest中是否含有参数token，如果没有则完成请求，终止转发，否则执行正常的逻辑。</p>
<p>然后需要将TokenFilter在工程的启动类中注入到Spring Ioc容器中，代码如下：</p>
<p>@Bean<br>public TokenFilter tokenFilter(){<br>        return new TokenFilter();<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>启动工程，使用curl命令请求：</p>
<p> curl localhost:8081/customer/123</p>
<p>1<br>2<br>可以看到请没有被转发，请求被终止，并在控制台打印了如下日志：</p>
<p>2018-11-16 15:30:13.543  INFO 19372 — [ctor-http-nio-2] gateway.TokenFilter                      : token is empty…<br>1<br>上面的日志显示了请求进入了没有传“token”的逻辑。</p>
<p>总结</p>
<p>本篇文章讲述了Spring Cloud Gateway中的过滤器，包括GatewayFilter和GlobalFilter。从官方文档的内置过滤器讲起，然后讲解自定义GatewayFilter、GatewayFilterFactory以及自定义的GlobalFilter。有很多内置的过滤器并没有讲述到，比如限流过滤器，这个我觉得是比较重要和大家关注的过滤器，将在之后的文章讲述。</p>
<p>在高并发的系统中，往往需要在系统中做限流，一方面是为了防止大量的请求使服务器过载，导致服务不可用，另一方面是为了防止网络攻击。</p>
<p>常见的限流方式，比如Hystrix适用线程池隔离，超过线程池的负载，走熔断的逻辑。在一般应用服务器中，比如tomcat容器也是通过限制它的线程数来控制并发的；也有通过时间窗口的平均速度来控制流量。常见的限流纬度有比如通过Ip来限流、通过uri来限流、通过用户访问频次来限流。</p>
<p>一般限流都是在网关这一层做，比如Nginx、Openresty、kong、zuul、Spring Cloud Gateway等；也可以在应用层通过Aop这种方式去做限流。</p>
<p>本文详细探讨在 Spring Cloud Gateway 中如何实现限流。</p>
<p>常见的限流算法</p>
<p>计数器算法</p>
<p>计数器算法采用计数器实现限流有点简单粗暴，一般我们会限制一秒钟的能够通过的请求数，比如限流qps为100，算法的实现思路就是从第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，那么后续的请求就会被全部拒绝。等到1s结束后，把计数恢复成0，重新开始计数。具体的实现可以是这样的：对于每次服务调用，可以通过AtomicLong#incrementAndGet()方法来给计数器加1并返回最新值，通过这个最新值和阈值进行比较。这种实现方式，相信大家都知道有一个弊端：如果我在单位时间1s内的前10ms，已经通过了100个请求，那后面的990ms，只能眼巴巴的把请求拒绝，我们把这种现象称为“突刺现象”</p>
<p>漏桶算法</p>
<p>漏桶算法为了消除”突刺现象”，可以采用漏桶算法实现限流，漏桶算法这个名字就很形象，算法内部有一个容器，类似生活用到的漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。不管服务调用方多么不稳定，通过漏桶算法进行限流，每10毫秒处理一次请求。因为处理的速度是固定的，请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在桶里，既然是个桶，肯定是有容量上限，如果桶满了，那么新进来的请求就丢弃。</p>
<p>在算法实现方面，可以准备一个队列，用来保存请求，另外通过一个线程池（ScheduledExecutorService）来定期从队列中获取请求并执行，可以一次性获取多个并发执行。</p>
<p>这种算法，在使用过后也存在弊端：无法应对短时间的突发流量。</p>
<p>令牌桶算法</p>
<p>从某种意义上讲，令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置qps为100，那么限流器初始化完成一秒后，桶中就已经有100个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的100个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。</p>
<p>实现思路：可以准备一个队列，用来保存令牌，另外通过一个线程池定期生成令牌放到队列中，每来一个请求，就从队列中获取一个令牌，并继续执行。</p>
<p>Spring Cloud Gateway限流</p>
<p>在Spring Cloud Gateway中，有Filter过滤器，因此可以在“pre”类型的Filter中自行实现上述三种过滤器。但是限流作为网关最基本的功能，Spring Cloud Gateway官方就提供了RequestRateLimiterGatewayFilterFactory这个类，适用Redis和lua脚本实现了令牌桶的方式。具体实现逻辑在RequestRateLimiterGatewayFilterFactory类中，lua脚本在如下图所示的文件夹中：</p>
<p>具体源码不打算在这里讲述，读者可以自行查看，代码量较少，先以案例的形式来讲解如何在Spring Cloud Gateway中使用内置的限流过滤器工厂来实现限流。</p>
<p>首先在工程的pom文件中引入gateway的起步依赖和redis的reactive依赖，代码如下：</p>
 <dependency><br>    <groupid>org.springframework.cloud</groupid><br>    <artifactid>spring-cloud-starter-gateway</artifactid><br></dependency>

<dependency><br>    <groupid>org.springframework.boot</groupid><br>    <artifatid>spring-boot-starter-data-redis-reactive<br></artifatid></dependency>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>在配置文件中做以下的配置：</p>
<p>server:<br>  port: 8081<br>spring:<br>  cloud:<br>    gateway:<br>      routes:</p>
<pre><code>- id: limit_route
  uri: http://httpbin.org:80/get
  predicates:
  - After=2017-01-20T17:42:47.789-07:00[America/Denver]
  filters:
  - name: RequestRateLimiter
    args:
      key-resolver: &apos;#{@hostAddrKeyResolver}&apos;
      redis-rate-limiter.replenishRate: 1
      redis-rate-limiter.burstCapacity: 3
</code></pre><p>  application:<br>    name: gateway-limiter<br>  redis:<br>    host: localhost<br>    port: 6379<br>    database: 0</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>在上面的配置文件，指定程序的端口为8081，配置了 redis的信息，并配置了RequestRateLimiter的限流过滤器，该过滤器需要配置三个参数：</p>
<p>burstCapacity，令牌桶总容量。<br>replenishRate，令牌桶每秒填充平均速率。<br>key-resolver，用于限流的键的解析器的 Bean 对象的名字。它使用 SpEL 表达式根据#{@beanName}从 Spring 容器中获取 Bean 对象。<br>KeyResolver需要实现resolve方法，比如根据Hostname进行限流，则需要用hostAddress去判断。实现完KeyResolver之后，需要将这个类的Bean注册到Ioc容器中。</p>
<p>public class HostAddrKeyResolver implements KeyResolver {</p>
<pre><code>@Override
public Mono&lt;String&gt; resolve(ServerWebExchange exchange) {
    return Mono.just(exchange.getRequest().getRemoteAddress().getAddress().getHostAddress());
}
</code></pre><p>}</p>
<p> @Bean<br>    public HostAddrKeyResolver hostAddrKeyResolver() {<br>        return new HostAddrKeyResolver();<br>    }</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>可以根据uri去限流，这时KeyResolver代码如下：</p>
<p>public class UriKeyResolver  implements KeyResolver {</p>
<pre><code>@Override
public Mono&lt;String&gt; resolve(ServerWebExchange exchange) {
    return Mono.just(exchange.getRequest().getURI().getPath());
}
</code></pre><p>}</p>
<p> @Bean<br>    public UriKeyResolver uriKeyResolver() {<br>        return new UriKeyResolver();<br>    }</p>
<p>也可以以用户的维度去限流：</p>
<p>   @Bean<br>    KeyResolver userKeyResolver() {<br>        return exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(“user”));<br>    }</p>
<p>用jmeter进行压测，配置10thread去循环请求lcoalhost:8081，循环间隔1s。从压测的结果上看到有部分请求通过，由部分请求失败。通过redis客户端去查看redis中存在的key。如下：</p>
<p>可见，RequestRateLimiter是使用Redis来进行限流的，并在redis中存储了2个key。关注这两个key含义可以看lua源代码。</p>
<p>在之前的文章介绍了Spring Cloud Gateway的Predict（断言）、Filter（过滤器），大家对Spring Cloud Gateway有初步的认识，其中在对服务路由转发的这一块，在之前的文章是采用硬编码的方式进行路由转发。这篇文章以案例的形式来讲解Spring Cloud Gateway如何配合服务注册中心进行路由转发。</p>
<p>工程介绍</p>
<p>本案例中使用spring boot的版本为2.0.3.RELEASE,spring cloud版本为Finchley.RELEASE。在中涉及到了三个工程， 分别为注册中心eureka-server、服务提供者service-hi、 服务网关service-gateway，如下：</p>
<p>工程名    端口    作用<br>eureka-server    8761    注册中心eureka server<br>service-hi    8762    服务提供者 eurka client<br>service-gateway    8081    路由网关 eureka client<br>这三个工程中，其中service-hi、service-gateway向注册中心eureka-server注册。用户的请求首先经过service-gateway，根据路径由gateway的predict 去断言进到哪一个 router， router经过各种过滤器处理后，最后路由到具体的业务服务，比如 service-hi。如图：</p>
<p>eureka-server、service-hi这两个工程直接复制于我的另外一篇文章<a href="https://blog.csdn.net/forezp/article/details/81040925" target="_blank" rel="noopener">https://blog.csdn.net/forezp/article/details/81040925</a> ，在这就不在重复，可以查看源码，源码地址见文末链接。 其中，service-hi服务对外暴露了一个RESTFUL接口“/hi”接口。现在重点讲解service-gateway。</p>
<p>gateway工程详细介绍</p>
<p>在gateway工程中引入项目所需的依赖，包括eureka-client的起步依赖和gateway的起步依赖，代码如下：</p>
<dependency><br>    <groupid>org.springframework.cloud</groupid><br>    <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid><br></dependency><br><dependency><br>    <groupid>org.springframework.cloud</groupid><br>    <artifactid>spring-cloud-starter-gateway</artifactid><br></dependency>

<p>在工程的配置文件application.yml中 ，指定程序的启动端口为8081，注册地址、gateway的配置等信息，配置信息如下：</p>
<p>server:<br>  port: 8081</p>
<p>spring:<br>  application:<br>    name: sc-gateway-service<br>  cloud:<br>    gateway:<br>      discovery:<br>        locator:<br>          enabled: true<br>          lowerCaseServiceId: true</p>
<p>eureka:<br>  client:<br>    service-url:<br>      defaultZone: <a href="http://localhost:8761/eureka/" target="_blank" rel="noopener">http://localhost:8761/eureka/</a></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>其中，spring.cloud.gateway.discovery.locator.enabled为true，表明gateway开启服务注册和发现的功能，并且spring cloud gateway自动根据服务发现为每一个服务创建了一个router，这个router将以服务名开头的请求路径转发到对应的服务。spring.cloud.gateway.discovery.locator.lowerCaseServiceId是将请求路径上的服务名配置为小写（因为服务注册的时候，向注册中心注册时将服务名转成大写的了），比如以/service-hi/*的请求路径被路由转发到服务名为service-hi的服务上。</p>
<p>在浏览器上请求输入localhost:8081/service-hi/hi?name=1323，网页获取以下的响应：</p>
<p>hi 1323 ,i am from port:8762</p>
<p>在上面的例子中，向gateway-service发送的请求时，url必须带上服务名service-hi这个前缀，才能转发到service-hi上，转发之前会将service-hi去掉。<br>那么我能不能自定义请求路径呢，毕竟根据服务名有时过于太长，或者历史的原因不能根据服务名去路由，需要由自定义路径并转发到具体的服务上。答案是肯定的是可以的，只需要修改工程的配置文件application.yml，具体配置如下：</p>
<p>spring:<br>  application:<br>    name: sc-gateway-server<br>  cloud:<br>    gateway:<br>      discovery:<br>        locator:<br>          enabled: false<br>          lowerCaseServiceId: true<br>      routes:</p>
<pre><code>- id: service-hi
  uri: lb://SERVICE-HI
  predicates:
    - Path=/demo/**
  filters:
    - StripPrefix=1
</code></pre><p>在上面的配置中，配置了一个Path 的predict,将以/demo/**开头的请求都会转发到uri为lb://SERVICE-HI的地址上，lb://SERVICE-HI即service-hi服务的负载均衡地址，并用StripPrefix的filter 在转发之前将/demo去掉。同时将spring.cloud.gateway.discovery.locator.enabled改为false，如果不改的话，之前的localhost:8081/service-hi/hi?name=1323这样的请求地址也能正常访问，因为这时为每个服务创建了2个router。</p>
<p>在浏览器上请求localhost:8081/demo/hi?name=1323，浏览器返回以下的响应：</p>
<p>hi 1323 ,i am from port:8762</p>
<p>1<br>2<br>返回的结果跟我们预想的一样。</p>
</string>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/29/spring-cloud-gateway-paper/" data-id="ck0qc72gd0011nbn4he1rk4bh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/08/14/redis_cluster/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">redis_cluster</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/economics/">economics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technique/">technique</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/29/spring-cloud-gateway-paper/">spring-cloud-gateway-paper</a>
          </li>
        
          <li>
            <a href="/2019/08/14/redis_cluster/">redis_cluster</a>
          </li>
        
          <li>
            <a href="/2019/08/07/前海母基金情况汇集/">前海母基金情况汇集</a>
          </li>
        
          <li>
            <a href="/2019/08/02/杨东来信/">杨东来信</a>
          </li>
        
          <li>
            <a href="/2019/07/03/kulese_经典观点/">kulese_经典观点</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>